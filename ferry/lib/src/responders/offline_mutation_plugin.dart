import 'dart:async';
import 'package:ferry/ferry.dart';
import 'package:meta/meta.dart';
import 'package:hive/hive.dart';
import 'package:built_value/serializer.dart';
import 'package:gql/ast.dart';
import 'package:rxdart/rxdart.dart';
import 'package:normalize/utils.dart';

import 'package:ferry/src/operation_request.dart';
import 'package:ferry/src/operation_response.dart';
import 'package:ferry/src/responder.dart';

typedef LinkExceptionHandler<TData, TVars> = void Function(
  OperationResponse<TData, TVars> response,
  EventSink<OperationResponse<TData, TVars>> sink,
);

class OfflineMutationPlugin extends Responder {
  /// A [hive] box where the mutation will be stored.
  final Box<Map<String, dynamic>> mutationQueueBox;

  /// The [Serializers] object generated by ferry's codegen.
  final Serializers serializers;

  final Cache cache;
  final StreamController<OperationRequest> requestController;

  /// A callback used to customize behavior when a mutation execution results in a [LinkException].
  final LinkExceptionHandler linkExceptionHandler;

  /// A [StreamController] that keeps track of network connection status.
  ///
  /// You must update this value when the network status changes.
  final isConnectedController = BehaviorSubject<bool>.seeded(false);

  /// [OfflineMutationPlugin] can be used to maintain an Offline Mutation queue.
  ///
  /// This plugin is intended to be an example for how offline mutations can be
  /// handled with ferry but doesn't address all edge cases.
  ///
  /// Some limitations include:
  /// 1. If the client shuts down during an inflight mutation (i.e. after a
  /// mutation has been sent to the server but before a response has been received),
  /// the mutation is assumed to have completed succesfully.
  /// 2. When coming back online, all queued mutations are executed immediately
  /// in parallel, not serially. This could lead to unexpected behavior.
  OfflineMutationPlugin({
    @required this.mutationQueueBox,
    @required this.serializers,
    @required this.cache,
    @required this.requestController,
    this.linkExceptionHandler,
  }) {
    isConnectedController.distinct().listen((isConnected) {
      if (isConnected) _handleOnConnect();
    });
  }

  void _handleOnConnect() => mutationQueueBox.values.forEach((json) {
        final OperationRequest req = serializers.deserialize(json);

        // Run unexecuted mutations
        requestController.add(req);
      });

  bool _isMutation(OperationRequest req) =>
      getOperationDefinition(
        req.operation.document,
        req.operation.operationName,
      ).type ==
      OperationType.mutation;

  @override
  Stream<OperationResponse<TData, TVars>> responseStream<TData, TVars>(
    OperationRequest<TData, TVars> request, [
    NextResponder<TData, TVars> forward,
  ]) =>
      _handleRequest(request, forward).transform(_responseTransformer());

  Stream<OperationResponse<TData, TVars>> _handleRequest<TData, TVars>(
    OperationRequest<TData, TVars> request, [
    NextResponder<TData, TVars> forward,
  ]) {
    // Forward along any operations that aren't Mutations
    if (_isMutation(request) == false) return forward(request);

    // If the client is online, execute the mutation
    if (isConnectedController.value) return forward(request);

    // Save mutation to the queue
    mutationQueueBox.put(
      request.requestId,
      serializers.serialize(request),
    );

    // Add an optimistic patch to the cache, if necessary
    if (request.optimisticResponse != null) {
      cache.writeQuery(
        request,
        request.optimisticResponse,
        optimistic: true,
        requestId: request.requestId,
      );
    }

    /// Don't forward
    return NeverStream();
  }

  StreamTransformer<OperationResponse<TData, TVars>,
          OperationResponse<TData, TVars>>
      _responseTransformer<TData, TVars>() => StreamTransformer.fromHandlers(
            handleData: (res, sink) {
              // Forward along any responses for operations that aren't Mutations
              if (_isMutation(res.operationRequest) == false) {
                return sink.add(res);
              }

              if (res.linkException is ServerException &&
                  linkExceptionHandler != null) {
                return linkExceptionHandler(res, sink);
              }

              // Forward response and remove mutation from queue
              sink.add(res);
              mutationQueueBox.delete(res.operationRequest.requestId);
            },
          );

  @override
  Future<void> dispose() => isConnectedController.close();
}
